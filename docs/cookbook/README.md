---
nav:
  title: Tutorial
toc: menu
---

# Getting started

## How to develop

This tutorial is suitable for people who are new to `qiankun`, and introduces how to build a `qiankun` project from 0.

### main app

The main app is not limited to the technical framework, it only needs to provide a container DOM, then register the micro apps and start it.

Install `qiankun` first :

```shell
$ yarn add qiankun # or npm i qiankun -S
```

Register the micro apps and start:

```js
import { registerMicroApps, start, initGlobalState } from 'qiankun';

registerMicroApps([
  {
    name: 'angularApp',
    entry: '//localhost:4200',
    container: '#container',
    activeRule: '/app-angular',
  },
  {
    name: 'reactApp',
    entry: '//localhost:3000',
    container: '#container',
    activeRule: '/app-react',
  },
  {
    name: 'vueApp',
    entry: '//localhost:8080',
    container: '#container',
    activeRule: '/app-vue',
  },
]);
// start qiankun
start();

// If there is no need for two-way value transfer, you can not use it initGlobalState
// init state 
const actions = initGlobalState({ username: 'zhangsan' });
actions.onGlobalStateChange((state, prev) => {
  // state: status after the change; prev : status before the change
  console.log(state, prev);
});
```

### micro app

Micro apps are divided into projects with `webpack` and without `webpack`. The things that need to be done for micro apps with `webpack` (mainly refers to Vue, React, Angular) are:

1. Added `public-path.js` file, used to modify the runtime `publicPath`。[What is publicPath at runtime?](https://webpack.js.org/guides/public-path/#on-the-fly)。

    <Alert>
    Note: `publicPath` at runtime and `publicPath` at build time are different, and the two cannot be equivalently substituted.
    </Alert>

2. The `history` route needs to set the route `base`, the value is the same as its `activeRule`, and the `hash` mode does not need to be set.
3. Import `public-path.js` at the top of the entry file, modify and export three `lifecycles` functions.
4. Modify the `webpack` configuration to allow cross-domain in development environments and bundle with `umd`.

The main modifications are the above four, which may change according to different situations of the project. For example, if your project is deployed separately from all other files of `index.html`, it means that you have set the `publicPath` at build time to the full path, so you don’t need to modify the `publicPath` at runtime (the first step can be omitted).

For micro app built without `webpack`, just mount `lifecycles` to `window`.

#### Angular micro app

Take the `angular 9` project generated by `Angular-cli 9` as an example, other versions of `angular` will be added later.

1. Add the file `public-path.js` in the `src` directory with the content:

    ```js
    if (window.__POWERED_BY_QIANKUN__) {
      // eslint-disable-next-line no-undef
      __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
    }
    ```

2. Set the `base` of `history` mode routing, `src/app/app-routing.module.ts` file:
  
    ```diff
    + import { APP_BASE_HREF } from '@angular/common';

    @NgModule({
      imports: [RouterModule.forRoot(routes)],
      exports: [RouterModule],
      // @ts-ignore
    +  providers: [{ provide: APP_BASE_HREF, useValue: window.__POWERED_BY_QIANKUN__ ? '/app-angular' : '/' }]
    })
    ```

3. Modify the entry file, `src/main.ts` file:

    ```ts
    import './public-path';
    import { enableProdMode, NgModuleRef } from '@angular/core';
    import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
    import { AppModule } from './app/app.module';
    import { environment } from './environments/environment';

    if (environment.production) {
      enableProdMode();
    }

    let app: void | NgModuleRef<AppModule>;
    async function render() {
      app = await platformBrowserDynamic()
        .bootstrapModule(AppModule)
        .catch(err => console.error(err));
    }
    if (!(window as any).__POWERED_BY_QIANKUN__) {
      render();
    }

    export async function bootstrap (props: Object) {
      console.log(props);
    }

    export async function mount (props: Object) {
      render();
    }

    export async function unmount (props: Object) {
      console.log(props);
      // @ts-ignore
      app.destroy();
    }
    ```

4. Modify `webpack` bundling configuration

    First install the `@angular-builders/custom-webpack` plugin. **Note: `Angular 9` project can only install `9.x` version, `angular 10` project can install the latest version**。

    ```bash
    npm i @angular-builders/custom-webpack@9.2.0 -D
    ```

    Add `custom-webpack.config.js` to the root directory with the content:

    ```js
    const appName = require('./package.json').name;
    module.exports = {
      devServer: {
        headers: {
          'Access-Control-Allow-Origin': '*',
        },
      },
      output: {
        library: `${appName}-[name]`,
        libraryTarget: 'umd',
        jsonpFunction: `webpackJsonp_${appName}`,
      },
    };
    ```

    Modify `angular.json`, change the values of `[packageName]> architect> build> builder` and `[packageName]> architect> serve> builder` to the plugins we installed, and add our webpack's configuration file to `[ packageName]> architect> build> options`.

    ```diff
    - "builder": "@angular-devkit/build-angular:browser",
    + "builder": "@angular-builders/custom-webpack:browser",
      "options": {
    +    "customWebpackConfig": {
    +      "path": "./custom-webpack.config.js"
    +    }
      }
    ```

    ```diff
    - "builder": "@angular-devkit/build-angular:dev-server",
    + "builder": "@angular-builders/custom-webpack:dev-server",
    ```

5. Solve the problem of `zone.js`
   
    Import `zone.js` in **main app**, just before loading the `angular` micro app.

    Delete the code of import `zone.js`  in the `src/polyfills.ts` of the micro app.

    ```diff
    - import 'zone.js/dist/zone';
    ```

    Add the following content to the `<head>` tag in the `src/index.html` of the micro app, which is used when the micro app is accessed independently.

    ```html
    <!-- Other CDN/local packages can also be used -->
    <script src="https://unpkg.com/zone.js" ignore></script>
    ```

6. Fix `ng build` comand's error report, modify `tsconfig.json` file, reference[issues/431](https://github.com/umijs/qiankun/issues/431).

    ```diff
    - "target": "es2015",
    + "target": "es5",
    + "typeRoots": [
    +   "node_modules/@types"
    + ],
    ```

7. In order to prevent the conflict of `<app-root></app-root>` when the main app or other micro apps are also `angular`, it is recommended to add a unique id to `<app-root>`, such as Say the current app name.

    src/index.html :
    ```diff
    - <app-root></app-root>
    + <app-root id="angular9"></app-root>
    ```

    src/app/app.component.ts :
    ```diff
    - selector: 'app-root',
    + selector: '#angular9 app-root',
    ```

Of course, you can also choose to use the `single-spa-angular` plugin, refer to[ single-spa-angular official website](https://single-spa.js.org/docs/ecosystem-angular) 和 [angular demo](https://github.com/umijs/qiankun/tree/master/examples/angular9)

#### React micro app

Take the `react 16` project generated by `create react app` as an example, with `react-router-dom` 5.x.

1. Add `public-path.js` in the `src` directory:

    ```js
    if (window.__POWERED_BY_QIANKUN__) {
      __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
    }
    ```
2. Set the `base` of `history` mode routing:

    ```html
    <!-- Not required for hash mode -->
    <BrowserRouter basename={window.__POWERED_BY_QIANKUN__ ? '/app-react' : '/'}>
    ```

3. The entry file `index.js` is modified. In order to avoid the root id `#root` from conflicting with other DOMs, the search scope needs to be limited.

    ```js
    import './public-path';
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './App';

    function render(props) {
      const { container } = props;
      ReactDOM.render(<App />, container ? container.querySelector('#root') : document.querySelector('#root'));
    }

    function storeTest(props) {
      props.onGlobalStateChange((value, prev) => console.log(`[onGlobalStateChange - ${props.name}]:`, value, prev), true);
      props.setGlobalState({
        ignore: props.name,
        user: {
          name: props.name,
        },
      });
    }

    if (!window.__POWERED_BY_QIANKUN__) {
      render({});
    }

    export async function bootstrap() {
      console.log('[react16] react app bootstraped');
    }

    export async function mount(props) {
      console.log('[react16] props from main framework', props);
      storeTest(props);
      render(props);
    }

    export async function unmount(props) {
      const { container } = props;
      ReactDOM.unmountComponentAtNode(container ? container.querySelector('#root') : document.querySelector('#root'));
    }
    ```

4. Modify `webpack` configuration

    Install the plugin `@rescripts/cli`, of course, you can also choose other plugins, such as `react-app-rewired`.
    ```dash 
    npm i -D @rescripts/cli
    ```

    Add `.rescriptsrc.js` to the root directory:
    ```js
    const { name } = require('./package');

    module.exports = {
      webpack: config => {
        config.output.library = `${name}-[name]`;
        config.output.libraryTarget = 'umd';
        config.output.jsonpFunction = `webpackJsonp_${name}`;
        config.output.globalObject = 'window';

        return config;
      },

      devServer: _ => {
        const config = _;

        config.headers = {
          'Access-Control-Allow-Origin': '*',
        };
        config.historyApiFallback = true;
        config.hot = false;
        config.watchContentBase = false;
        config.liveReload = false;

        return config;
      },
    };
    ```

    Modify `package.json`:
    ```diff
    -   "start": "react-scripts start",
    +   "start": "rescripts start",
    -   "build": "react-scripts build",
    +   "build": "rescripts build",
    -   "test": "react-scripts test",
    +   "test": "rescripts test",
    -   "eject": "react-scripts eject"
    ```
#### Vue micro app

Take the `vue 2.x` project generated by `vue-cli 3+` as an example, and add it after the `vue 3` version becomes stable.

1. Add `public-path.js` in the `src` directory:

    ```js
    if (window.__POWERED_BY_QIANKUN__) {
      __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
    }
    ```

3. The entry file `main.js` is modified. In order to avoid the root id `#app` from conflicting with other DOMs, the search scope needs to be limited.

    ```js
    import './public-path';
    import Vue from 'vue';
    import VueRouter from 'vue-router';
    import App from './App.vue';
    import routes from './router';
    import store from './store';

    Vue.config.productionTip = false;

    let router = null;
    let instance = null;
    function render(props = {}) {
      const { container } = props;
      router = new VueRouter({
        // hash Mode does not need to set base
        base: window.__POWERED_BY_QIANKUN__ ? '/app-vue/' : '/',
        mode: 'history',
        routes,
      });

      instance = new Vue({
        router,
        store,
        render: h => h(App),
      }).$mount(container ? container.querySelector('#app') : '#app');
    }

    // standalone
    if (!window.__POWERED_BY_QIANKUN__) {
      render();
    }

    function storeTest(props) {
      props.onGlobalStateChange &&
        props.onGlobalStateChange(
          (value, prev) => console.log(`[onGlobalStateChange - ${props.name}]:`, value, prev),
          true,
        );
      props.setGlobalState &&
        props.setGlobalState({
          ignore: props.name,
          user: {
            name: props.name,
          },
        });
    }

    export async function bootstrap() {
      console.log('[vue] vue app bootstraped');
    }
    export async function mount(props) {
      console.log('[vue] props from main framework', props);
      storeTest(props); // test two-way data transfer
      render(props);
    }
    export async function unmount() {
      instance.$destroy();
      instance.$el.innerHTML = '';
      instance = null;
      router = null;
    }
    ```

3.  Modify `webpack` configuration（`vue.config.js`）:

    ```js
    const { name } = require('./package');
    module.exports = {
      devServer: {
        headers: {
          'Access-Control-Allow-Origin': '*',
        },
      },
      configureWebpack: {
        output: {
          library: `${name}-[name]`,
          libraryTarget: 'umd',// bundle the micro app into umd library format
          jsonpFunction: `webpackJsonp_${name}`,
        },
      },
    };
    ```

#### Micro app built without webpack

Some apps that are not built by `webpack`, such as `jQuery` app, `jsp` app, can be handled according to this.

Before modify, please make sure that the resources such as pictures, audio and video in your project can be loaded normally. If the addresses of these resources are all full paths (for example, `https://qiankun.umijs.org/logo.png`), there is no problem. If they are all relative paths, you need to upload these resources to the server first and reference the full path.

The only change is that we need to declare a script tag, to export the `lifecycles`

example:

1. declare entry script

    ```diff
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Purehtml Example</title>
    </head>
    <body>
      <div>
        Purehtml Example
      </div>
    </body>

    + <script src="//yourhost/entry.js" entry></script>
    </html>
    ```

2. export lifecycles in the entry

    ```javascript
    const render = ($) => {
      $('#purehtml-container').html("Hello, render with jQuery");
      return Promise.resolve();
    }

    (global => {
      global['purehtml'] = {
        bootstrap: () => {
          console.log('purehtml bootstrap');
          return Promise.resolve();
        },
        mount: () => {
          console.log('purehtml mount');
          return render($)
        },
        unmount: () => {
          console.log('purehtml unmount');
          return Promise.resolve();
        },
      };
    })(window);
    ```

refer to the [purehtml examples](https://github.com/umijs/qiankun/tree/master/examples/purehtml)

At the same time, [the subApp must support the CORS](#must-a-sub-app-asset-support-cors)

#### umi-qiankun app

For the tutorial of `umi-qiankun`, please go to [umi official website](https://umijs.org/zh-CN/plugins/plugin-qiankun) and [umi-qiankun official demo](https://github.com/umijs/umi-plugin-qiankun/tree/master/examples)

### How to choose the routing mode of micro app

The three routes `react-router`, `angular-router`, and `vue-router` all support the `hash` and `history` modes. The different modes used by micro apps are slightly different in `qiankun`.

#### `activeRule` uses `location.pathname` to distinguish micro apps

When the main app uses `location.pathname` to distinguish micro apps, micro apps can be in `hash` and `history` modes.

When registering micro apps, `activeRule` needs to be written like this:

```js
registerMicroApps([
  { 
    name: 'app', 
    entry: 'http://localhost:8080', 
    container: '#container', 
    activeRule: '/app', 
  },
]);
```

1. When the micro app is in `history` mode, just set the route `base`.

2. When the micro app is in the `hash` mode, the performance of the three routes is inconsistent

    | routing        | main app jump `/app/#/about`   | special configuration     |
    | ---------------| -------------------------------| --------------------------|
    | vue-router     | Response `about` routing       | none                      |
    | react-router   | not responding `about` routing | none                      |
    | angular-router | Response `about` routing       | need to set `--base-href` |

    `Angular` app set `--base-href` in `package.json`:
    ```diff
    - "start": "ng serve",
    + "start": "ng serve --base-href /angular9",
    - "build": "ng build",
    + "build": "ng build --base-href /angular9",
    ```

    After bundled and deployed, the `angular` micro app can be accessed by the main app, but the lazy-loaded route during independent access will report an error and the path is incorrect. There are two solutions:

    - Solution 1: Modify `public-path.js` to:

        ```js
        __webpack_public_path__ = window.__POWERED_BY_QIANKUN__ ? window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ : `http://${ip}:${port}/`; // Fill in your actual deployment address
        ```
    - Solution 2: Modify the bundling command and deploy the micro app in the `angular9` directory:

        ```diff
        - "build": "ng build",
        + "build": "ng build --base-href /angular9 --deploy-url /angular9/",
        ```

#### activeRule uses hash to distinguish micro apps

When the micro apps are all in the `hash` mode, `hash` can be used to distinguish the micro apps, and the routing mode of the main app is not limited.

When registering micro apps, `activeRule` needs to be written like this:

```js
const getActiveRule = hash => location => location.hash.startsWith(hash);
registerMicroApps([
  { 
    name: 'app-hash', 
    entry: 'http://localhost:8080', 
    container: '#container', 
    activeRule: getActiveRule('#/app-hash'), 
    // Here you can also write `activeRule:'#/app-hash'` directly,
    // but if the main app is in history mode or the main app is deployed in a non-root directory, this writing will not take effect.
  },
]);
```

The `react-router` and `angular-router` micro-apps need to set the value of `activeRule` to the route's `base`, written in the same way as `history`.

In the `hash` mode of the `vue-router` app, the `base` for routing is not supported. You need to create an additional empty routing page and use all other routes as its children:

```js
const routes = [
  {
    path: '/app-vue-hash',
    name: 'Home',
    component: Home,
    children: [
      // All other routes are written here
    ]
  }
]
```

#### When there are multiple micro apps at the same time

If a page displays multiple micro apps at the same time, you need to use `loadMicroApp` to load them.

If these micro apps have routing jump requirements, to ensure that these routes do not interfere with each other, you need to use the `momery` routing. `vue-router` uses the `abstract` mode, `react-router` uses the `memory history` mode, and `angular-router` does not support it.

## How to deploy

**Recommendation**: The main app and micro apps are developed and deployed independently, that is, they belong to different git repositories and services.

### Scenario 1: The main app and micro apps are deployed to the same server (the same IP and port)

If the number of servers is limited, or cannot be cross-domain and other reasons, the main app and micro apps need to be deployed together.

The usual practice is to deploy the main app in the first-level directory and the micro apps in the second/third-level directory.

If you want to deploy a micro app in a non-root directory, you need to do two things before bundling the micro app:

1. You must configure the `publicPath` when building `webpack` as the **directory name**. For more information, please see [webpack official instructions](https://webpack.js.org/configuration/output/#outputpublicpath) 和 [vue-cli3 official instructions](https://cli.vuejs.org/config/#publicpath).

2. The micro app of the `history` route needs to set the `base`, the value is **directory name**, which is used when the micro app is accessed independently.

Pay attention to three points after deployment:

1. `activeRule` cannot be the same as **the real access path of the micro app**, otherwise it will directly become the micro app page when refreshed on the main app page.
2. The real access path of the micro app is the `entry` of the micro app, and the `entry` can be a relative path.
3. The `/` at the end of the `entry` path of the micro app cannot be omitted, otherwise the `publicPath` will be set incorrectly. For example, if the access path of the child item is `http://localhost:8080/app1`, then `entry` It is `http://localhost:8080/app1/`.

There are two specific deployment methods, choose one of them.

#### Solution 1: All micro apps are placed in a folder with a special name that do not have the same name as micro apps (**recommended**)

Suppose we have a main app and 6 micro apps ( respectively `vue-hash`, `vue-history`, `react-hash`, `react-history`, `angular-hash`, `angular-history`) And place it as follows after bundling:

```
└── html/                     # root folder
    |
    ├── child/                # the folder of all micro apps
    |   ├── vue-hash/         # the folder of the micro app `vue-hash`
    |   ├── vue-history/      # the folder of the micro app `vue-history`
    |   ├── react-hash/       # the folder of the micro app `react-hash`
    |   ├── react-history/    # the folder of the micro app `react-history`
    |   ├── angular-hash/     # the folder of the micro app `angular-hash`
    |   ├── angular-history/  # the folder of the micro app `angular-history`
    ├── index.html            # index.html of the main app
    ├── css/                  # the css folder of the main app
    ├── js/                   # the js folder of the main app
```

At this time, you need to set the `publicPath` and the route `base` of the `history` mode when the micro app is built, and then bundle them into the corresponding directory.

| app             | routing base            | publicPath              | real access path                             |
| --------------- | ------------------------| ------------------------| ---------------------------------------------|
| vue-hash        | none                    | /child/vue-hash/        | http://localhost:8080/child/vue-hash/        |
| vue-history     | /child/vue-history/     | /child/vue-history/     | http://localhost:8080/child/vue-history/     |
| react-hash      | none                    | /child/react-hash/      | http://localhost:8080/child/react-hash/      |
| react-history   | /child/react-history/   | /child/react-history/   | http://localhost:8080/child/react-history/   |
| angular-hash    | none                    | /child/angular-hash/    | http://localhost:8080/child/angular-hash/    |
| angular-history | /child/angular-history/ | /child/angular-history/ | http://localhost:8080/child/angular-history/ |

- `vue-history` micro app

    Routing's base configuration:
    ```js
    base: window.__POWERED_BY_QIANKUN__ ? '/app-vue/' : '/child/vue-history/',
    ```
    Webpack's publicPath configuration（`vue.config.js`）:
    ```js
    module.exports = {
      publicPath: '/child/vue-history/'
    }
    ```

- `react-history` micro app

    Routing's base configuration:
    ```html
    <BrowserRouter basename={window.__POWERED_BY_QIANKUN__ ? '/app-react' : '/child/react-history/'}>
    ```
    Webpack's publicPath configuration:
    ```js
    module.exports = {
      output: {
        publicPath: '/child/react-history/',
      }
    }
    ```

- `angular-history` micro app

    Routing's base configuration:
    ```js
    providers: [{ 
      provide: APP_BASE_HREF, 
      useValue: window.__POWERED_BY_QIANKUN__ ? '/app-angular/' : '/child/angular-history/' 
    }]
    ```
    The `publicPath` of webpack is set by `deploy-url`, modify `package.json`:
    ```diff
    - "build": "ng build",
    + "build": "ng build --deploy-url /child/angular-history/",
    ```

Then the `registerMicroApps` function at this time is like this (you need to ensure that `activeRule` and `entry` are different):

```js
registerMicroApps([
  {
    name: 'app-vue-hash', 
    entry: '/child/vue-hash/', // http://localhost:8080/child/vue-hash/
    container: '#container', 
    activeRule: '/app-vue-hash', 
  },
  { 
    name: 'app-vue-history',
    entry: '/child/vue-history/', // http://localhost:8080/child/vue-history/
    container: '#container', 
    activeRule: '/app-vue-history',
  },
  // angular and react same as above
],
```

So far, the main app and the micro apps can run normally, but the main app and the `vue-history`, `react-history`, and `angular-history` micro apps are `history` routes. The problem of refreshing 404 needs to be solved. nginx` also needs to be configured:

```conf
server {
  listen       8080;
  server_name  localhost;

  location / {
    root   html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }

  location /child/vue-history {
    root   html;
    index  index.html index.htm;
    try_files $uri $uri/ /child/vue-history/index.html;
  }
  # The configuration of angular-history and react-history is the same as above
}
```

#### Solution 2: Place the micro apps directly in the secondary directory, but set a special `activeRule`

```
└── html/                 # root folder
    |
    ├── vue-hash/         # the folder of the micro app `vue-hash`
    ├── vue-history/      # the folder of the micro app `vue-history`
    ├── react-hash/       # the folder of the micro app `react-hash`
    ├── react-history/    # the folder of the micro app `react-history`
    ├── angular-hash/     # the folder of the micro app `angular-hash`
    ├── angular-history/  # the folder of the micro app `angular-history`
    ├── index.html        # index.html of the main app
    ├── css/              # the css folder of the main app
    ├── js/               # the js folder of the main app
```

The basic operation is the same as above, just make sure that `activeRule` is different from the storage path name of the micro app.

### Scenario 2: The main app and micro apps are deployed on different servers and accessed through Nginx proxy

This is generally done because **the main app is not allowed to access micro apps across domains**. The practice is to forward all requests for a special path on the main app server to the micro app server, that is, a "micro app deployed on the main app server" effect is achieved through the proxy.

For example, the main app is on the A server, and the micro app is on the B server. The path `/app1` is used to distinguish the micro app, that is, all requests starting with `/app1` on the A server are forwarded to the B server.

the `Nginx` proxy configuration of the main app is：

```
/app1/ {
  proxy_pass http://www.b.com/app1/;
  proxy_set_header Host $host:$server_port;    
}
```

When the main app registers micro apps, `entry` can be a relative path, and `activeRule` cannot be the same as `entry` (otherwise the main app page refreshes and becomes a micro app):

```js
registerMicroApps([
  {
    name: 'app1', 
    entry: '/app1/', // http://localhost:8080/app1/
    container: '#container', 
    activeRule: '/child-app1', 
  },
],
```

For micro apps bundled by `webpack`, the `publicPath` bundled by the micro app's `webpack` needs to be configured as `/app1/`, otherwise the micro app's `index.html` can be requested correctly, But the path of `js/css` in the micro app's `index.html` will not carry `/app1/`.

```js
module.exports = {
  output: {
    publicPath: `/app1/`,
  }
}
```

After adding `/app1/` to the `publicPath` of the micro app, it must be deployed in the `/app1` directory, otherwise it cannot be accessed independently.

In addition, if you don't want the micro app to be accessed independently through the proxy path, you can judge based on some information requested. The requesting micro app in the main app is requested with `fetch`, which can include parameters and `cookie`. For example, judge by request header parameters:

```js
if ($http_custom_referer != "main") {
  rewrite /index /404.html;
}
```

## Upgrade from 1.x version to 2.x version

The micro apps does not need to be changed, and the main app needs to be adjusted.

The basic modification of `registerMicroApps` function is as follows:

1. Remove the `render` parameter and only need to provide the container.
2. Add the `loader` parameter to display the `loading` status. Originally, the `loading` status was provided to the `render` parameter.
3. The `activeRule` parameter can be abbreviated as `/app`, which is compatible with the previous function writing.
4. The `RegisterMicroAppsOpts` parameter is removed and placed in the parameter of the `start` function.

The basic modification of the `start` function is as follows:

1. The `jsSandbox` configuration has been removed and changed to `sandbox`, and the optional values have also been modified.
2. Added `getPublicPath` and `getTemplate` to replace `RegisterMicroAppsOpts`.